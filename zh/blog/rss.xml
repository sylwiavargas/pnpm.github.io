<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/zh/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Wed, 29 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <item>
            <title><![CDATA[pnpm 的 2021 年]]></title>
            <link>https://pnpm.io/zh/blog/2021/12/29/yearly-update</link>
            <guid>/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。]]></description>
            <content:encoded><![CDATA[<p>现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。</p><h2 class="anchor anchorWithStickyNavbar_tDxo" id="使用量">使用量<a class="hash-link" href="#使用量" title="标题直链">​</a></h2><h3 class="anchor anchorWithStickyNavbar_tDxo" id="下载统计">下载统计<a class="hash-link" href="#下载统计" title="标题直链">​</a></h3><p>我今年的目标是在下载量上击败 Bower。 我们在<a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">11月</a>实现了这个目标：</p><p><img loading="lazy" src="/zh/assets/images/pnpm-vs-bower-stats-6ec69a7308f5fbc1433420b1b2f7457f.png" width="976" height="389" class="img_l_xh"></p><p>2021 年 pnpm 的下载量约为 2020 年的<a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">3倍 </a>：</p><p><img loading="lazy" src="/zh/assets/images/download-stats-2021-1418562cb03abd558c4a6b4b17155227.png" width="983" height="394" class="img_l_xh"></p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>这些统计数据甚至没有衡量 pnpm 可能被安装的所有不同的方式！ 他们只测量了 <a href="https://www.npmjs.com/package/pnpm" target="_blank" rel="noopener noreferrer">pnpm npm package</a> 的下载量。 今年我们还添加了 pnpm 的二进制编译版本，它们的交付的方式是不同的。</p></div></div><h3 class="anchor anchorWithStickyNavbar_tDxo" id="文档访问">文档访问<a class="hash-link" href="#文档访问" title="标题直链">​</a></h3><p>我们使用 Google Analytics 从我们的文档中收集了一些非个性化的统计数据。 在 2021 年，有时我们每周有超过 2,000 名独立访客。</p><p><img loading="lazy" src="/zh/assets/images/ga-unique-visits-2021-b8bc3649f680565127696c85bdd4b701.png" width="665" height="509" class="img_l_xh"></p><p>我们的大部分用户来自美国和中国。</p><p><img loading="lazy" src="/zh/assets/images/countries-2021-8eb9625e1798649ee04451dfb10ac851.png" width="585" height="498" class="img_l_xh"></p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="github-stars">GitHub stars<a class="hash-link" href="#github-stars" title="标题直链">​</a></h3><p>我们的 <a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">主 GitHub 仓库</a> 今年获得了 +5,000 颗星。</p><p><img loading="lazy" src="/zh/assets/images/stars-2021-0061c16f424e33ba0db224d82bcb53f3.png" width="913" height="800" class="img_l_xh"></p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="新用户">新用户<a class="hash-link" href="#新用户" title="标题直链">​</a></h3><p>我们今年最大的新用户是 <a href="https://github.com/pnpm/pnpm.github.io/pull/89" target="_blank" rel="noopener noreferrer">Bytedance</a>（TikTok 背后的公司）。</p><p>此外，许多优秀的开源项目开始使用 pnpm。 有些人转而使用 pnpm 是因为它对 monorepos 的大力支持：</p><ul><li><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener noreferrer">Vue</a></li><li><a href="https://github.com/vitejs/vite" target="_blank" rel="noopener noreferrer">Vite</a></li><li>和 <a href="https://pnpm.io/workspaces#usage-examples" target="_blank" rel="noopener noreferrer">其他</a></li></ul><p>有些人之所以切换为 pnpm，是因为他们喜欢 pnpm 的高效、快速和美观：</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736" target="_blank" rel="noopener noreferrer">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701" target="_blank" rel="noopener noreferrer">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419" target="_blank" rel="noopener noreferrer">Browserslist</a></li></ul><h2 class="anchor anchorWithStickyNavbar_tDxo" id="功能亮点">功能亮点<a class="hash-link" href="#功能亮点" title="标题直链">​</a></h2><h3 class="anchor anchorWithStickyNavbar_tDxo" id="新的锁文件格式自-v600">新的锁文件格式（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0" target="_blank" rel="noopener noreferrer">v6.0.0</a>）<a class="hash-link" href="#新的锁文件格式自-v600" title="标题直链">​</a></h3><p>今年第一个也是最重要的变化之一是新的 <code>pnpm-lock.yaml</code> 格式。 这是一个突破性的变化，所以我们不得不发布 v6。 但它是成功的。 旧的锁文件经常导致 Git 冲突。 由于引入了新格式，我们没有收到任何关于 Git 冲突的投诉。</p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="管理-nodejs-版本自-v6120">管理 Node.js 版本（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0" target="_blank" rel="noopener noreferrer">v6.12.0</a>）<a class="hash-link" href="#管理-nodejs-版本自-v6120" title="标题直链">​</a></h3><p>我们发布了一个允许管理 Node.js 版本的新命令（ <code>pnpm env</code> ）。 因此，您可以使用 pnpm 而不是像 nvm 或 Volta 这样的 Node.js 版本管理器。</p><p>此外，pnpm 是作为独立的可执行文件提供的，因此即使系统上没有预装 Node.js，您也可以运行它。</p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="注入本地依赖自-v6200">注入本地依赖（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0" target="_blank" rel="noopener noreferrer">v6.20.0</a>）<a class="hash-link" href="#注入本地依赖自-v6200" title="标题直链">​</a></h3><p>您可以 “inject” 本地依赖项。 默认情况下，本地依赖项被符号链接至 <code>node_modules</code>。但有了这个新功能，你可以指示 pnpm 硬链接包内的文件。</p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="改进了-peerdependency-问题的报告自-v6240">改进了 peerDependency 问题的报告（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0" target="_blank" rel="noopener noreferrer">v6.24.0</a>）<a class="hash-link" href="#改进了-peerdependency-问题的报告自-v6240" title="标题直链">​</a></h3><p>PeerDependency 问题曾经被打印为纯文本，很难理解。 它们现在都分组并打印在一个很好的层次结构中。</p><h2 class="anchor anchorWithStickyNavbar_tDxo" id="竞争">竞争<a class="hash-link" href="#竞争" title="标题直链">​</a></h2><h3 class="anchor anchorWithStickyNavbar_tDxo" id="yarn">Yarn<a class="hash-link" href="#yarn" title="标题直链">​</a></h3><p>Yarn 在 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-" target="_blank" rel="noopener noreferrer">v3.1</a> 添加了 pnpm 链接器。 因此 Yarn 可以创建一个类似于 pnpm 创建的 node_modules 目录结构。</p><p>此外，Yarn 团队计划实现内容可寻址存储，以提高磁盘空间效率。</p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="npm">npm<a class="hash-link" href="#npm" title="标题直链">​</a></h3><p>Npm 团队决定也采用 pnpm 使用的符号链接的 node_modules 目录结构（相关 <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md" target="_blank" rel="noopener noreferrer">RFC</a>）。</p><h3 class="anchor anchorWithStickyNavbar_tDxo" id="others">Others<a class="hash-link" href="#others" title="标题直链">​</a></h3><p>用 Zig 编写的 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1" target="_blank" rel="noopener noreferrer">Bun</a> 以及 <a href="https://github.com/voltpkg/volt" target="_blank" rel="noopener noreferrer">Volt</a> 都声称比 npm/Yarn/pnpm 更快。 我还没有对这些新的包管理器进行基准测试。</p><h2 class="anchor anchorWithStickyNavbar_tDxo" id="未来的计划">未来的计划<a class="hash-link" href="#未来的计划" title="标题直链">​</a></h2><p>更快，更好，最好。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm的node_modules配置选项]]></title>
            <link>https://pnpm.io/zh/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。]]></description>
            <content:encoded><![CDATA[<p>创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。</p><h2 class="anchor anchorWithStickyNavbar_tDxo" id="默认配置">默认配置<a class="hash-link" href="#默认配置" title="标题直链">​</a></h2><p>默认情况下，pnpm v5将创建一个“半严格”的node_modules。 “半严格”意味着您的应用程序将只能导入 <code>package.json</code> 中列出的依赖项(但也有例外)。 然而，你所依赖的那些包将能访问任何其他的包。</p><p>默认配置如下所示：</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有包到 node_modules/.pnpm/node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有名称包含types的包至根，以便Typescript能找到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*types*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有ESLint相关的包至根</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*eslint*</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_tDxo" id="plugnplay-最严格的配置">Plug'n'Play. 最严格的配置<a class="hash-link" href="#plugnplay-最严格的配置" title="标题直链">​</a></h2><p>自v5.9起，pnpm支持 <a href="https://yarnpkg.com/features/pnp" target="_blank" rel="noopener noreferrer">Yarn的Plug'n'Play</a>。 使用PnP，您的应用以及你所依赖的包都只能访问他们声明的依赖关系。 这比设置 <code>hoist = false</code> 更为严格，因为在monorepo中，您的应用甚至连根项目的依赖项也无法访问。</p><p>要使用 Plug'n'Play，请设置以下设置:</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">node-linker=pnp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">symlink=false</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_tDxo" id="严格的模块目录">严格的模块目录<a class="hash-link" href="#严格的模块目录" title="标题直链">​</a></h2><p>如果您尚未准备好使用PnP，也可以通过将提升配置设置为false来仅允许程序包访问其自身的依赖项，确保其“严格”性：</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">hoist=false</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>但是，如果您的某些依赖项需要访问它们在依赖项中没有的程序包，则有两种选择：</p><ol><li><p>创建 <code>pnpmfile.js</code> 并使用一个 <a href="/zh/pnpmfile">hook</a> 将缺少的依赖项添加到包的清单中。</p></li><li><p>添加到 <code>hoist-pattern</code> 中。 例如，如果未找到的模块是 <code>babel-core</code>，则将以下设置添加到 <code>.npmrc</code>：</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=babel-core</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li></ol><h2 class="anchor anchorWithStickyNavbar_tDxo" id="最坏的情况----提升至根">最坏的情况 -- 提升至根<a class="hash-link" href="#最坏的情况----提升至根" title="标题直链">​</a></h2><p>即使使用pnpm的默认配置，某些工具也可能无法工作，默认配置下所有内容都悬挂在虚拟存储的根目录中，而某些软件包则悬挂在根目录中。 在这种情况下，您可以将所有内容或部分依赖关系提升到modules目录的根目录。</p><p>要将所有内容提升到node_modules的根目录：</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">shamefully-hoist=true</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>按匹配规则提升:</p><div class="codeBlockContainer__UmT language-ini theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-ini codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=babel-*</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[平铺的结构不是 node_modules 的唯一实现方式]]></title>
            <link>https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 node_modules 结构。 为什么不是平铺的？ 次级依赖去哪了？]]></description>
            <content:encoded><![CDATA[<p>Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 <code>node_modules</code> 结构。 为什么不是平铺的？ 次级依赖去哪了？</p><blockquote><p>我将默认这篇文章的读者已经熟悉了 npm 与 yarn 创建的平铺的 <code>node_modules</code>。 如果你不明白为什么 npm3 需要开始在 v3 中使用平铺的 <code>node_modules</code>，你可以在这里找到一些背景知识 <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">Why should we use pnpm?</a>。</p></blockquote><p>那么为什么 pnpm 的 <code>node_modules</code> 会如此不同寻常呢？ 让我们创建两个目录，并在其中一个执行 <code>npm add express</code>， 然后在另一个中执行 <code>pnpm add express</code>。 以下是你在第一个目录中的 <code>node_modules</code> 的顶级项目：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">.bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie-signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">depd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destroy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ee-first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">encodeurl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">escape-html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules" target="_blank" rel="noopener noreferrer">这里</a>看到整个目录。</p><p>然后这一个<code>node_modules</code> 是你通过 pnpm 创建的得到的：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.modules.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules" target="_blank" rel="noopener noreferrer">这里</a>查看。</p><p>那么所有的（次级）依赖去哪了呢？ <code>node_modules</code> 中只有一个叫 <code>.pnpm</code> 的文件夹以及一个叫做 <code>express</code> 的符号链接。 不错，我们只安装了 <code>express</code>，所以它是唯一一个你的应用必须拥有访问权限的包。</p><blockquote><p>要了解关于为什么 pnpm （对依赖项访问控制）的严格把关是件好事，请阅读<a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" target="_blank" rel="noopener noreferrer">此文</a></p></blockquote><p>让我们看看在 <code>express</code> 中都有些什么：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▸ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .modules.yaml</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><code>express</code> 没有 <code>node_modules</code>? <code>express</code> 的所有依赖都去哪里了？</p><p>诀窍是 <code>express</code> 只是一个符号链接。 当 Node.js 解析依赖的时候，它使用这些依赖的真实位置，所以它不保留符号链接。 但是你可能就会问了，<code>express</code> 的真实位置在哪呢？</p><p>在这里：<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express" target="_blank" rel="noopener noreferrer">node_modules/.pnpm/express@4.17.1/node_modules/express</a>。</p><p>OK，所以我们现在知道了 <code>.pnpm/</code> 文件夹的用途。 <code>.pnpm/</code> 以平铺的形式储存着所有的包，所以每个包都可以在这种命名模式的文件夹中被找到：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>我们称之为虚拟存储目录。</p><p>这个平铺的结构避免了 npm v2 创建的嵌套 <code>node_modules</code> 引起的长路径问题，但与 npm v3,4,5,6 或 yarn v1 创建的平铺的 <code>node_modules</code> 不同的是，它保留了包之间的相互隔离。</p><p>现在让我们看看 <code>express</code> 的真实位置：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>这是个骗局吗？ 还是没有 <code>node_modules</code>！ pnpm 的 <code>node_modules</code> 结构的第二个诀窍是包的依赖项与依赖包的实际位置位于同一目录级别。 所以 <code>express</code> 的依赖不在 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> 而是在 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules" target="_blank" rel="noopener noreferrer">.pnpm/express@4.17.1/node_modules/</a>：</p><div class="codeBlockContainer__UmT language-text theme-code-block"><div class="codeBlockContent_exuh" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_NB0K thin-scrollbar"><code class="codeBlockLines_szY_"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ accepts@1.3.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ array-flatten@1.1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▾ express@4.16.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Readme.md</span><br></span></code></pre><button type="button" aria-label="复制代码" title="复制" class="copyButton_cYky clean-btn"><span class="copyButtonIcons_AHZ9" aria-hidden="true"><svg class="copyButtonIcon_GFPJ" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_AgvU" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><code>express</code> 所有的依赖都软链至了 <code>node_modules/.pnpm/</code> 中的对应目录。 把 <code>express</code> 的依赖放置在同一级别避免了循环的软链。</p><p>正如你所看到的，即使 pnpm 的 <code>node_modules</code> 结构一开始看起来很奇怪：</p><ol><li>它完全适配了 Node.js。</li><li>包与其依赖被完美地组织在一起。</li></ol><p>有 peer 依赖的包的结构<a href="/zh/how-peers-are-resolved">更加复杂</a>一些，但思路是一样的：使用软链与平铺目录来构建一个嵌套结构。</p>]]></content:encoded>
        </item>
    </channel>
</rss>