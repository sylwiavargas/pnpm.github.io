<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/ko/blog</id>
    <title>pnpm Blog</title>
    <updated>2021-12-29T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/ko/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/ko/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[pnpm의 2021년]]></title>
        <id>/2021/12/29/yearly-update</id>
        <link href="https://pnpm.io/ko/blog/2021/12/29/yearly-update"/>
        <updated>2021-12-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.]]></summary>
        <content type="html"><![CDATA[<p>올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.</p><h2 class="anchor anchorWithStickyNavbar_JTcU" id="사용량">사용량<a class="hash-link" href="#사용량" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_JTcU" id="다운로드-통계">다운로드 통계<a class="hash-link" href="#다운로드-통계" title="Direct link to heading">​</a></h3><p>올해 저의 목표는 다운로드 수에서 Bower를 이기는 것이 었습니다. 우리는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">11월</a>에 그 목표를 달성할 수 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/pnpm-vs-bower-stats-6ec69a7308f5fbc1433420b1b2f7457f.png" width="976" height="389"></p><p>pnpm은 2020년에 비해 2021년에는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">약 3배 더 많이</a> 다운로드되었습니다.</p><p><img loading="lazy" src="/ko/assets/images/download-stats-2021-1418562cb03abd558c4a6b4b17155227.png" width="983" height="394"></p><p>:::참고</p><p>이 통계는 pnpm이 설치될 수 있는 모든 다양한 방법을 측정하지도 않습니다! 그들은 단지 <a href="https://www.npmjs.com/package/pnpm" target="_blank" rel="noopener noreferrer">pnpm npm 패키지</a>의 다운로드만 측정합니다. 올해 우리는 또한 pnpm의 컴파일 된 바이너리 버전을 추가하며 이는 다른식으로 출하됩니다.</p><p>:::</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="문서-방문">문서 방문<a class="hash-link" href="#문서-방문" title="Direct link to heading">​</a></h3><p>Google Analytics를 사용하여 문서에서 개인화되지 않은 통계를 수집합니다. 2021년에는 때때로 일주일에 2,000명 이상의 고유 방문자가 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/ga-unique-visits-2021-b8bc3649f680565127696c85bdd4b701.png" width="665" height="509"></p><p>대부분의 사용자는 미국과 중국 출신입니다.</p><p><img loading="lazy" src="/ko/assets/images/countries-2021-8eb9625e1798649ee04451dfb10ac851.png" width="585" height="498"></p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="깃허브-스타">깃허브 스타<a class="hash-link" href="#깃허브-스타" title="Direct link to heading">​</a></h3><p><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">주요 GitHub 저장소</a>는 올해 +5,000개의 별을 받았습니다.</p><p><img loading="lazy" src="/ko/assets/images/stars-2021-0061c16f424e33ba0db224d82bcb53f3.png" width="913" height="800"></p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="신규-사용자">신규 사용자<a class="hash-link" href="#신규-사용자" title="Direct link to heading">​</a></h3><p>올해 가장 큰 신규 사용자는 <a href="https://github.com/pnpm/pnpm.github.io/pull/89" target="_blank" rel="noopener noreferrer">Bytedance</a> (TikTok 뒤에 있는 회사)입니다.</p><p>또한 많은 훌륭한 오픈 소스 프로젝트에서 pnpm을 사용하기 시작했습니다. 일부는 모노레포에 대한 뛰어난 지원 때문에 pnpm으로 전환했습니다.</p><ul><li><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener noreferrer">Vue</a></li><li><a href="https://github.com/vitejs/vite" target="_blank" rel="noopener noreferrer">Vite</a></li><li>및 <a href="https://pnpm.io/workspaces#usage-examples" target="_blank" rel="noopener noreferrer">다른 것들</a></li></ul><p>일부는 pnpm이 얼마나 효율적이고 빠르며 아름다운지를 좋아하기 때문에 전환했습니다.</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736" target="_blank" rel="noopener noreferrer">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701" target="_blank" rel="noopener noreferrer">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419" target="_blank" rel="noopener noreferrer">Browserslist</a></li></ul><h2 class="anchor anchorWithStickyNavbar_JTcU" id="주요-기능">주요 기능<a class="hash-link" href="#주요-기능" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_JTcU" id="새로운-locfile-형식-v600-이후">새로운 locfile 형식 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0" target="_blank" rel="noopener noreferrer">v6.0.0</a> 이후)<a class="hash-link" href="#새로운-locfile-형식-v600-이후" title="Direct link to heading">​</a></h3><p>올해 처음이자 가장 중요한 변경 사항 중 하나는 새로운 <code>pnpm-lock.yaml</code> 형식입니다. 이것은 브레이킹 체인지였기 때문에 v6을 출시해야 했습니다. 그러나 그것은 성공적이었습니다. 이전 lockfile은 Git 충돌을 자주 일으켰습니다. 새로운 형식이 도입된 이후로 Git 충돌에 대한 불만은 접수되지 않았습니다.</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="nodejs-버전-관리-v6120-이후">Node.js 버전 관리 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0" target="_blank" rel="noopener noreferrer">v6.12.0</a> 이후)<a class="hash-link" href="#nodejs-버전-관리-v6120-이후" title="Direct link to heading">​</a></h3><p>Node.js 버전을 관리할 수 있는 새로운 명령어 (<code>pnpm env</code>)를 출하했습니다. 따라서 nvm 또는 Volta와 같은 Node.js 버전 관리자 대신 pnpm을 사용할 수 있습니다.</p><p>또한 pnpm은 독립 실행형 실행 파일로 제공되므로 시스템에 Node.js가 사전 설치되어 있지 않아도 실행할 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="로컬-의존성-주입-v6200-이후">로컬 의존성 주입 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0" target="_blank" rel="noopener noreferrer">v6.20.0</a> 이후)<a class="hash-link" href="#로컬-의존성-주입-v6200-이후" title="Direct link to heading">​</a></h3><p>여러분은 로컬 의존성을 "주입"할 수 있습니다. 기본적으로 로컬 의존성은 <code>node_modules</code>에 심볼릭 링크되지만 이 새로운 기능을 사용하면 pnpm에 패키지 파일을 하드 링크하도록 지시할 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="피어-의존성-문제에-대한-보고-기능-개선-v6240-이후">피어 의존성 문제에 대한 보고 기능 개선 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0" target="_blank" rel="noopener noreferrer">v6.24.0</a> 이후)<a class="hash-link" href="#피어-의존성-문제에-대한-보고-기능-개선-v6240-이후" title="Direct link to heading">​</a></h3><p>피어 의존성 문제는 일반 텍스트로 출력되어 이해하기 어려웠습니다. 이제 모두 그룹화되어 멋진 계층 구조로 출력됩니다.</p><h2 class="anchor anchorWithStickyNavbar_JTcU" id="경쟁">경쟁<a class="hash-link" href="#경쟁" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_JTcU" id="yarn">Yarn<a class="hash-link" href="#yarn" title="Direct link to heading">​</a></h3><p>Yarn은 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-" target="_blank" rel="noopener noreferrer">v3.1</a>에서 pnpm 링커를 추가했습니다. 따라서 Yarn은 pnpm이 생성하는 것과 유사한 노드 모듈 디렉토리 구조를 생성할 수 있습니다.</p><p>또한 Yarn 팀은 디스크 공간 효율성을 높이기 위해 콘텐츠 주소 지정 가능 스토리지를 구현할 계획입니다.</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="npm">npm<a class="hash-link" href="#npm" title="Direct link to heading">​</a></h3><p>npm 팀은 pnpm이 사용하는 심볼릭 링크된 node-modules 디렉토리 구조 (<a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md" target="_blank" rel="noopener noreferrer">RFC</a>와 관련된)도 채택하기로 결정했습니다.</p><h3 class="anchor anchorWithStickyNavbar_JTcU" id="기타">기타<a class="hash-link" href="#기타" title="Direct link to heading">​</a></h3><p>Zig로 작성된 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1" target="_blank" rel="noopener noreferrer">Bun</a>과 Rust로 작성된 <a href="https://github.com/voltpkg/volt" target="_blank" rel="noopener noreferrer">Volt</a> 모두 npm/Yarn/pnpm보다 빠르다고 주장합니다. 이 새로운 패키지 관리자를 아직 벤치마킹하지 않았습니다.</p><h2 class="anchor anchorWithStickyNavbar_JTcU" id="향후-계획">향후 계획<a class="hash-link" href="#향후-계획" title="Direct link to heading">​</a></h2><p>더 빠르고, 더 좋고, 최고가 될 것 입니다.</p>]]></content>
        <author>
            <name>졸탄 코찬</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm을 사용한 노드 모듈 구성 옵션]]></title>
        <id>/2020/10/17/node-modules-configuration-options-with-pnpm</id>
        <link href="https://pnpm.io/ko/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[nodemodules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 nodemodules을 만드는 옵션도 있습니다.]]></summary>
        <content type="html"><![CDATA[<p>node_modules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 node_modules을 만드는 옵션도 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_JTcU" id="기본-설정">기본 설정<a class="hash-link" href="#기본-설정" title="Direct link to heading">​</a></h2><p>기본적으로 pnpm v5는 반만 엄격한 node_modules를 만듭니다. 반만 엄격하다는 것은 응용 프로그램이 <code>package.json</code>에 의존성으로 추가된 패키지만 요구할 수 있음을 의미합니다 (몇 가지 예외는 제외). 그러나 여러분의 의존성은 모든 패키지에 접근할 수 있습니다.</p><p>기본 구성은 다음과 같습니다.</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 패키지는  node_modules/.pnpm/node_modules에 호이스팅되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 타입은 타입스크립트를 행복하게 만들기 위해 루트로 호이스팅되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*types*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 ESLint와 관련된 패키지는 마찬가지로 호이스팅 되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*eslint*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_JTcU" id="plugnplay-가장-엄격한-구성">Plug'n'Play. 가장 엄격한 구성<a class="hash-link" href="#plugnplay-가장-엄격한-구성" title="Direct link to heading">​</a></h2><p>pnpm은 v5.9 부터 <a href="https://yarnpkg.com/features/pnp" target="_blank" rel="noopener noreferrer">Yarn의 Plug'n ' Play</a> 를 지원합니다. PnP를 사용하면 애플리케이션과 애플리케이션의 의존성이 선언된 의존성에만 접근할 수 있습니다. 이것은 monorepo 내부에서 애플리케이션이 루트 프로젝트의 의존성에도 접근할 수 없기 때문에 <code>hoist=false</code> 로 설정하는 것보다 훨씬 더 엄격합니다.</p><p>Plug'n'Play를 사용하려면 다음 설정을 설정하세요.</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">node-linker=pnp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">symlink=false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_JTcU" id="엄격하고-전통적인-모듈-디렉토리">엄격하고 전통적인 모듈 디렉토리<a class="hash-link" href="#엄격하고-전통적인-모듈-디렉토리" title="Direct link to heading">​</a></h2><p>아직 PnP를 사용할 준비가 되지 않은 경우에도 여전히 엄격할 수 있으며 호이스팅 구성을 false로 설정하여 패키지가 자체 의존성에만 접근하도록 허용할 수 있습니다.</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">hoist=false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>그러나 의존성 중 일부가 그들의 의존성에 없는 패키지에 접근하려고 하는 경우 두 가지 옵션이 있습니다.</p><ol><li><p><code>pnpmfile.js</code>를 만들고 <a href="/ko/pnpmfile">hook</a>를 사용하여 패키지의 매니페스트에 누락된 의존성을 추가합니다.</p></li><li><p><code>hoist-pattern</code> 설정에 패턴을 추가합니다. 예를 들어, 그 찾을 수 없는 모듈이 <code>babel-core</code>이면, 다음 설정을 <code>.npmrc</code>추가합니다.</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=babel-core</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div></li></ol><h2 class="anchor anchorWithStickyNavbar_JTcU" id="최악의-경우---루트로-호이스팅">최악의 경우 - 루트로 호이스팅<a class="hash-link" href="#최악의-경우---루트로-호이스팅" title="Direct link to heading">​</a></h2><p>일부 도구는 모든 것을 가상 저장소의 루트에 호이스팅하고 일부 패키지를 루트에 호이스팅하는 pnpm의 기본 구성에서도 작동하지 않을 수 있습니다. 이 경우, 모든 항목 또는 의존성의 하위 집합을 모듈 디렉터리의 루트로 호이스팅할 수 있습니다.</p><p>모든 항목을 node_modules의 루트로 호이스팅하기:</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">shamefully-hoist=true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>패턴과 일치하는 패키지만 호이스팅하기:</p><div class="codeBlockContainer_AIsy language-ini theme-code-block"><div class="codeBlockContent_hC3r ini"><pre tabindex="0" class="prism-code language-ini codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=babel-*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[평탄한 node_modules가 유일한 방법은 아닙니다.]]></title>
        <id>/2020/05/27/flat-node-modules-is-not-the-only-way</id>
        <link href="https://pnpm.io/ko/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[pnpm의 신규 사용자들이 pnpm에서 생성하는 node_modules의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?]]></summary>
        <content type="html"><![CDATA[<p>pnpm의 신규 사용자들이 pnpm에서 생성하는 <code>node_modules</code>의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?</p><blockquote><p>저는 이 기사의 독자들이 npm과 Yarn에서 생성하는 <code>node_modules</code>에 이미 익숙하다고 가정합니다. 만약 npm 3이 플랫 <code>node_modules</code> 를 사용하여 v3 에서 시작해야 하는 이유를 이해하지 못하는 경우, <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">에서 몇 가지 사전 히스토리를 찾을 수 있습니다.</a>.</p></blockquote><p>그러면 왜 pnpm의 <code>node_modules</code> 디렉토리는 특이할까요? 두 개의 디렉토리를 만들고 그 중 하나에서 <code>npm add express</code> 을 실행하고 다른 하나에서 <code>pnpm add express</code>을 실행합니다. 다음은 첫 번째 디렉토리의 <code>node_modules</code>에서 얻을 수 있는 상위 항목입니다.</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">.bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie-signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">depd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destroy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ee-first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">encodeurl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">escape-html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules" target="_blank" rel="noopener noreferrer">여기</a>에서 전체 디렉토리를 볼 수 있습니다.</p><p>그리고 이것이 pnpm에 의해 만들어진 <code>node_modules</code>에서 얻은 항목입니다.</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.modules.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules" target="_blank" rel="noopener noreferrer">여기</a>에서 전체 디렉토리를 확인할 수 있습니다.</p><p>그래서 모든 의존성들은 어디에 있을까요? <code>node_modules</code> 에는 <code>.pnpm</code> 이라는 하나의 폴더뿐이며 <code>express</code>라는 심볼릭 링크만 있습니다. 음, 우리는 오직 <code>express</code>만 설치했으므로 당신의 애플리케이션이 접근할 수 있는 유일한 패키지입니다.</p><blockquote><p>왜 pnpm의 엄격함이 좋은지 <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" target="_blank" rel="noopener noreferrer">여기</a>서 자세히 읽어보세요.</p></blockquote><p><code>express</code>안에 무엇이 있는지 봅시다.</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▸ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .modules.yaml</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p><code>express</code> 에는 <code>node_modules</code>가 없네요? <code>express</code>의 모든 의존성들은 어디에 있을까요?</p><p>트릭은 <code>express</code>가 단지 심볼릭 링크라는 것입니다. Node.js는 의존성을 해결할 때, 실제 위치를 사용하므로 심볼릭 링크를 유지하지 않습니다. 하지만 <code>express</code>의 실제 위치가 어디냐고 당신은 물어볼 수 있겠죠?</p><p>여기: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express" target="_blank" rel="noopener noreferrer">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>자, 이제 우리는 <code>.pnpm/</code> 폴더의 목적을 알고 있습니다. <code>.pnpm/</code> 는 모든 패키지를 플랫 폴더 구조로 저장하므로 모든 패키지는 다음 패턴으로 이름이 지정된 폴더에서 찾을 수 있습니다.</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm/&lt;이름&gt;@&lt;버전&gt;/node_modules/&lt;이름&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>우리는 이것을 가상 저장소 디렉토리라고 부릅니다.</p><p>이러한 평탄한 구조는 npm v2에 의해 만들어진 중첩 형식의 <code>node_modules </code> 에서의 긴 경로 문제를 회피하지만, npm v3,4,5,6 또는 Yarn v1에 의해 생성된 평탄한 <code>node _modules</code>와는 달리 패키지를 격리된 상태로 유지합니다.</p><p>이제 <code>express</code>의 실제 위치를 알아보겠습니다.</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p>사기일까요? <code>node _modules</code>가 여전히 없네요! pnpm에서 <code>node_modules</code> 구조의 두 번째 트릭은 패키지의 의존성들이 의존 패키지의 실제 위치와 동일한 디렉토리 레벨에 있다는 것입니다. 따라서 <code>express</code>의 의존성들은 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>에 있는 것이 아니라 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules" target="_blank" rel="noopener noreferrer">.pnpm/express@4.17.1/node_modules/</a>에 있습니다:</p><div class="codeBlockContainer_AIsy language-text theme-code-block"><div class="codeBlockContent_hC3r text"><pre tabindex="0" class="prism-code language-text codeBlock_FQ0X thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_FEsq"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ accepts@1.3.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ array-flatten@1.1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▾ express@4.16.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Readme.md</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_KLm8 clean-btn">Copy</button></div></div><p><code>express</code>의 모든 의존성들은 <code>node_modules/.pnpm/</code> 내의 적절한 디렉토리에 대한 심볼릭 링크입니다. <code>express</code>의 의존성들을 한 단계 위로 배치하면 순환 심볼릭 링크를 피할 수 있습니다.</p><p>보시다시피 pnpm의 <code>node_modules</code> 구조가 처음에는 특이한 것 같죠:</p><ol><li>Node.js와 완전히 호환됩니다.</li><li>패키지는 의존성과 함께 멋지게 그룹화됩니다.</li></ol><p>피어 의존성을 가진 패키지의 경우 구조가 <a href="/ko/how-peers-are-resolved">조금 더 복잡</a>하지만 생각은 동일합니다: 평탄한 디렉토리 구조로 중첩구조를 만들기 위해 심볼릭 링크를 사용하기</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>